/* Minified CSMA */

class CSMA{constructor(e){for(this.line=[];e-- >0;)this.line.push([]);this.nodes=[],this.verbose=!1}}function initCsma(e,t){let i=document.createElement("table"),o=document.createElement("tr"),n=document.createElement("tr");for(let e of t.line.entries()){let e=document.createElement("td"),l=document.createElement("td"),d=document.createElement("input");d.type="text";let s=document.createElement("input");s.type="button",s.value="add node",l.appendChild(d),l.appendChild(s),s.addEventListener("click",addNode(t,i)),o.appendChild(e),n.appendChild(l)}i.appendChild(o),i.appendChild(n),i.id="csma";let l=document.createElement("input");l.type="button",l.value="step",l.addEventListener("click",nextStep(t,i)),e.appendChild(i),e.appendChild(l)}function addNode(e){return function(t){let i=t.target.parentNode.children[0].value,o=t.target.parentNode.cellIndex;if(""!==i){let n=e.addNode(i,o),l=t.target.parentNode;for(;l.firstChild;)l.removeChild(l.firstChild);l.textContent=`${i}\r\n${n.timeout}`}}}function nextStep(e,t){return function(){e.step();for(let[i,o]of e.line.entries()){t.children[0].children[i].textContent="";for(let e of o)t.children[0].children[i].textContent+=`${e.id}\r\n`}for(let i of e.nodes){let e=t.children[1].children[i.position];e.textContent=`${i.id}\r\n${i.timeout}`,i.emit?i.collision?e.style="background-color: red;":e.style="background-color: blue;":e.style="background-color: white;"}}}CSMA.prototype.addNode=function(e,t,i=.05){if(t>=this.line.length)throw"wrong position";if(this.nodes.some(i=>i.id==e||i.position==t))throw"this id or position is taken";let o=0;for(;Math.random()>i;)o++;return this.nodes.push({id:e,position:t,emit:!1,collision:!1,timeout:o,probability:i,mult:1}),this.verbose&&console.log(`Node ${e} is added at ${t}`),this.nodes[this.nodes.length-1]},CSMA.prototype.step=function(){let e=[],t=this.line.length;for(;t-- >0;)e.push([]);for(let[t,i]of this.line.entries())for(let o of i)-1===o.d&&(this.verbose&&console.log(`<-[${o.id}]`),0!==t&&e[t-1].push({d:-1,id:o.id})),0===o.d&&(this.verbose&&console.log(`<-[${o.id}]->`),0!==t&&e[t-1].push({d:-1,id:o.id}),t!==this.line.length-1&&e[t+1].push({d:1,id:o.id})),1===o.d&&(this.verbose&&console.log(`[${o.id}]->`),t!==this.line.length-1&&e[t+1].push({d:1,id:o.id}));this.line=e;for(let e of this.nodes)if(e.emit||0!==e.timeout||(this.line[e.position].length>0?(e.timeout+=Math.floor(this.line.length/2),this.verbose&&console.log(`${e.id} waits for line to be clear`)):(this.verbose&&console.log(`${e.id} is starting to emit`),e.timeout=2*this.line.length+1,e.emit=!0)),e.emit&&(this.verbose&&console.log(`${e.id} emits`),this.line[e.position].push({d:0,id:e.id}),!e.collision&&this.line[e.position].filter(t=>t.id!=e.id).length&&(this.verbose&&console.log(`${e.id} detected collision`),e.collision=!0)),e.timeout--,e.emit&&0===e.timeout)if(e.emit=!1,e.collision){let t=[];for(let i=0;i<=e.mult;i++)t.push(Math.pow(2,i));e.timeout=this.line.length*t[Math.floor(Math.random()*t.length)],e.mult++,e.collision=!1,this.verbose&&console.log(`${e.id} waits ${e.timeout}`)}else{for(e.mult=1;Math.random()>e.probability;)e.timeout++;this.verbose&&console.log(`${e.id} successfully transmitted`)}};
